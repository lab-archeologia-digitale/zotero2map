'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _asyncToGenerator = require('@babel/runtime-corejs3/helpers/asyncToGenerator');
var _defineProperty = require('@babel/runtime-corejs3/helpers/defineProperty');
var _includesInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/includes');
var _Promise = require('@babel/runtime-corejs3/core-js-stable/promise');
var _trimInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/trim');
var SparkMD5 = require('spark-md5');
var _parseInt = require('@babel/runtime-corejs3/core-js-stable/parse-int');
var _matchAllInstanceProperty = require('@babel/runtime-corejs3/core-js/instance/match-all');
var _reduceInstanceProperty = require('@babel/runtime-corejs3/core-js-stable/instance/reduce');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _includesInstanceProperty__default = /*#__PURE__*/_interopDefaultLegacy(_includesInstanceProperty);
var _Promise__default = /*#__PURE__*/_interopDefaultLegacy(_Promise);
var _trimInstanceProperty__default = /*#__PURE__*/_interopDefaultLegacy(_trimInstanceProperty);
var SparkMD5__default = /*#__PURE__*/_interopDefaultLegacy(SparkMD5);
var _parseInt__default = /*#__PURE__*/_interopDefaultLegacy(_parseInt);
var _matchAllInstanceProperty__default = /*#__PURE__*/_interopDefaultLegacy(_matchAllInstanceProperty);
var _reduceInstanceProperty__default = /*#__PURE__*/_interopDefaultLegacy(_reduceInstanceProperty);

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var parseIntHeaders = (headers, headerName) => {
  var value = headers && headers.get(headerName);
  return value === null ? null : _parseInt__default["default"](value, 10);
};

/**
 * @class Represents a generic Zotero API response. Usually a specialised variant inheriting from
 * this class is returned when doing an API request
 * @memberof module:zotero-api-client
 * @inner
 */
class ApiResponse {
  constructor(data, options, response) {
    this.raw = data;
    this.options = options;
    this.response = response;
  }

  /**
  * Name of the class, useful to determine instance of which specialised class
    has been returned
  * @return {string} name of the class
  */
  getResponseType() {
    return 'ApiResponse';
  }

  /**
  * Content of the response. Specialised classes provide extracted data depending on context.
  * @return {object}
  */
  getData() {
    return this.raw;
  }

  /**
  * Links available in the response. Specialised classes provide extracted links depending on context.
  * @return {object}
  */
  getLinks() {
    if ('links' in this.raw) {
      return this.raw.links;
    }
    return null;
  }

  /**
  * Meta data available in the response. Specialised classes provide extracted meta data depending on context.
  * @return {object}
  */
  getMeta() {
    if ('meta' in this.raw) {
      return this.raw.meta;
    }
    return null;
  }

  /**
  * Contents of "Last-Modified-Version" header in response if present. Specialised classes provide
    version depending on context
  * @return {?number} Version of the content in response
  */
  getVersion() {
    var _this$response;
    return parseIntHeaders((_this$response = this.response) === null || _this$response === void 0 ? void 0 : _this$response.headers, 'Last-Modified-Version');
  }
}

/**
 * @class Represents a response to a GET request containing a single entity
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class SingleReadResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'SingleReadResponse';
  }

  /**
   * @return {Object} entity returned in this response
   */
  getData() {
    return this.raw && 'data' in this.raw ? this.raw.data : this.raw;
  }
}

/**
 * @class represnets a response to a GET request containing multiple entities
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class MultiReadResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'MultiReadResponse';
  }
  /**
   * @return {Array} a list of entities returned in this response
   */
  getData() {
    return this.raw.map(r => 'data' in r ? r.data : 'tag' in r ? {
      tag: r.tag
    } : r);
  }

  /**
  * @return {Array} a list of links, indexes of the array match indexes of entities in {@link
  module:zotero-api-client~MultiReadResponse#getData}
  */
  getLinks() {
    return this.raw.map(r => 'links' in r && r.links || null);
  }

  /**
  * @return {Array} a list of meta data, indexes of the array match indexes of entities in {@link
  module:zotero-api-client~MultiReadResponse#getData}
  */
  getMeta() {
    return this.raw.map(r => 'meta' in r && r.meta || null);
  }

  /**
  * @return {string} Total number of results
  */
  getTotalResults() {
    var _this$response2;
    return parseIntHeaders((_this$response2 = this.response) === null || _this$response2 === void 0 ? void 0 : _this$response2.headers, 'Total-Results');
  }

  /**
  * @return {object} Parsed content of "Link" header as object where value of "rel" is a key and
    the URL is the value, contains values for "next", "last" etc.
  */
  getRelLinks() {
    var _this$response$header, _this$response3, _context;
    var links = (_this$response$header = (_this$response3 = this.response) === null || _this$response3 === void 0 ? void 0 : _this$response3.headers.get('link')) !== null && _this$response$header !== void 0 ? _this$response$header : '';
    var matches = Array.from(_matchAllInstanceProperty__default["default"](links).call(links, /<(.*?)>;\s+rel="(.*?)"/ig));
    return _reduceInstanceProperty__default["default"](_context = Array.from(matches)).call(_context, (acc, _ref) => {
      var [_match, url, rel] = _ref;
      acc[rel] = url;
      return acc;
    }, {});
  }
}

/**
 * @class Represents a response to a PUT or PATCH request
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class SingleWriteResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'SingleWriteResponse';
  }
  /**
   * @return {Object} For put requests, this represents a complete, updated object.
   *                  For patch requests, this reprents only updated fields of the updated object.
   */
  getData() {
    return _objectSpread$2(_objectSpread$2({}, this.options.body), {}, {
      version: this.getVersion()
    });
  }
}

/**
 * @class Represents a response to a POST request
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class MultiWriteResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'MultiWriteResponse';
  }
  /**
   * @return {Boolean} Indicates whether all write operations were successful
   */
  isSuccess() {
    return Object.keys(this.raw.failed).length === 0;
  }

  /**
   * Returns all entities POSTed in an array. Entities that have been written successfully
   * are returned updated, other entities are returned unchanged. It is advised to verify
   * if request was entirely successful (see isSuccess and getError) before using this method.
   * @return {Array} A modified list of all entities posted.
   */
  getData() {
    return this.options.body.map((item, index) => {
      index = index.toString();
      if (index in this.raw.success) {
        var remoteItem = this.raw.successful && this.raw.successful[index] || {};
        return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, item), remoteItem.data), {}, {
          key: this.raw.success[index],
          version: this.getVersion()
        });
      } else {
        return item;
      }
    });
  }

  /**
  * @see {@link module:zotero-api-client~ApiResponse#getLinks}
  */
  getLinks() {
    return this.options.body.map((_, index) => {
      if ("successful" in this.raw) {
        var entry = this.raw.successful[index.toString()];
        if (entry) {
          return entry.links || {};
        }
      }
      return null;
    });
  }

  /**
  * @see {@link module:zotero-api-client~ApiResponse#getMeta}
  */
  getMeta() {
    return this.options.body.map((_, index) => {
      if ("successful" in this.raw) {
        var entry = this.raw.successful[index.toString()];
        if (entry) {
          return entry.meta || {};
        }
      }
      return null;
    });
  }

  /**
   * Returns all errors that have occurred.
   * @return {Object} Errors object where keys are indexes of the array of the original request and values are the erorrs occurred.
   */
  getErrors() {
    var errors = {};
    for (var i of Object.keys(this.raw.failed)) {
      errors[_parseInt__default["default"](i, 10)] = this.raw.failed[i];
    }
    return errors;
  }

  /**
   * Allows obtaining updated entity based on its key, otherwise identical to getEntityByIndex
   * @param  {String} key
   * @throws {Error} If key is not present in the request
   * @see {@link module:zotero-api-client.getEntityByIndex}
   */
  getEntityByKey(key) {
    var index = this.options.body.findIndex(entity => {
      return entity.key === key;
    });
    if (index > -1) {
      return this.getEntityByIndex(index);
    }
    throw new Error("Key ".concat(key, " is not present in the request"));
  }

  /**
   * Allows obtaining updated entity based on its index in the original request
   * @param  {Number} index
   * @return {Object}
   * @throws {Error} If index is not present in the original request
   * @throws {Error} If error occured in the POST for selected entity. Error message will contain reason for failure.
   */
  getEntityByIndex(index) {
    if (typeof index === 'string') {
      index = _parseInt__default["default"](index, 10);
    }
    if (index.toString() in this.raw.success) {
      var remoteItem = this.raw.successful && this.raw.successful[index.toString()] || {};
      return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, this.options.body[index]), remoteItem.data), {}, {
        key: this.raw.success[index],
        version: this.getVersion()
      });
    }
    if (index.toString() in this.raw.unchanged) {
      return this.options.body[index];
    }
    if (index.toString() in this.raw.failed) {
      throw new Error("".concat(this.raw.failed[index.toString()].code, ": ").concat(this.raw.failed[index.toString()].message));
    }
    throw new Error("Index ".concat(index, " is not present in the reponse"));
  }
}

/**
 * @class Represents a response to a DELETE request
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class DeleteResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'DeleteResponse';
  }
}

/**
 * @class Represents a response to a file upload request
 * @extends ApiResponse
 * @property {Object} authResponse     - Response object for the stage 1 (upload authorisation)
 *                                       request
 * @property {Object} response 	       - alias for "authResponse" 
 * @property {Object} uploadResponse   - Response object for the stage 2 (file upload) request
 * @property {Objext} registerResponse - Response object for the stage 3 (upload registration)
 *                                       request
 * @memberof module:zotero-api-client
 * @inner
 */
class FileUploadResponse extends ApiResponse {
  constructor(data, options, authResponse, uploadResponse, registerResponse) {
    super(data, options, authResponse);
    this.uploadResponse = uploadResponse;
    this.registerResponse = registerResponse;
  }

  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'FileUploadResponse';
  }

  /**
  * @see {@link module:zotero-api-client~ApiResponse#getVersion}
  */
  getVersion() {
    var _this$registerRespons, _this$response4;
    return this.registerResponse ? parseIntHeaders((_this$registerRespons = this.registerResponse) === null || _this$registerRespons === void 0 ? void 0 : _this$registerRespons.headers, 'Last-Modified-Version') : parseIntHeaders((_this$response4 = this.response) === null || _this$response4 === void 0 ? void 0 : _this$response4.headers, 'Last-Modified-Version');
  }
}

/**
 * @class Represents a response to a file download request
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class FileDownloadResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'FileDownloadResponse';
  }
}

/**
 * @class Represents a response containing temporary url for file download
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class FileUrlResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'FileUrlResponse';
  }
}

/**
 * @class Represents a raw response, e.g. to data requests with format other than json
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class RawApiResponse extends ApiResponse {
  constructor(rawResponse, options) {
    super(rawResponse, options, rawResponse);
  }

  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'RawApiResponse';
  }
}

/**
 * @class Represents a response for pretended request, mostly for debug purposes. See {@link module:zotero-api-client.api~pretend}
 * @extends ApiResponse
 * @memberof module:zotero-api-client
 * @inner
 */
class PretendResponse extends ApiResponse {
  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'PretendResponse';
  }

  /**
  * @return {Object} For pretended request version will always be null.
  */
  getVersion() {
    return null;
  }
}

/**
 * @class Represents an error response from the api
 * @extends Error
 * @property {Object} response - Response object for the request, with untouched body
 * @property {String} message  - What error occurred, ususally contains response code and status
 * @property {String} reason   - More detailed reason for the failure, if provided by the API
 * @property {String} options  - Configuration object used for this request
 * @memberof module:zotero-api-client
 * @inner
 */
class ErrorResponse extends Error {
  constructor(message, reason, response, options) {
    super(message);
    this.response = response;
    this.reason = reason;
    this.message = message;
    this.options = options;
  }

  /**
  * @see {@link module:zotero-api-client~ApiResponse#getResponseType}
  */
  getResponseType() {
    return 'ErrorResponse';
  }
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var headerNames = {
  authorization: 'Authorization',
  contentType: 'Content-Type',
  ifMatch: 'If-Match',
  ifModifiedSinceVersion: 'If-Modified-Since-Version',
  ifNoneMatch: 'If-None-Match',
  ifUnmodifiedSinceVersion: 'If-Unmodified-Since-Version',
  zoteroApiKey: 'Zotero-API-Key',
  zoteroWriteToken: 'Zotero-Write-Token'
};
var queryParamsWithArraySupport = ["tag", "itemTag"];
var queryParamNames = ['collectionKey', 'content', 'direction', 'format', 'include', 'includeTrashed', 'itemKey', 'itemQ', 'itemQMode', 'itemTag', 'itemType', 'limit', 'linkMode', 'locale', 'q', 'qmode', 'searchKey', 'since', 'sort', 'start', 'style', 'tag'];
var fetchParamNames = ['body', 'cache', 'credentials', 'method', 'mode', 'redirect', 'signal'];
var resourcesSpecs = [
//name in resource, name in the url (usually the same but there are exceptions)
{
  'name': 'library',
  urlPart: 'library',
  isKeyResource: true
}, {
  'name': 'collections',
  urlPart: 'collections',
  isKeyResource: true
}, {
  'name': 'publications',
  urlPart: 'publications',
  isKeyResource: false
}, {
  'name': 'items',
  urlPart: 'items',
  isKeyResource: true
}, {
  'name': 'searches',
  urlPart: 'searches',
  isKeyResource: true
}, {
  'name': 'top',
  urlPart: 'top',
  isKeyResource: false
}, {
  'name': 'trash',
  urlPart: 'trash',
  isKeyResource: false
}, {
  'name': 'tags',
  urlPart: 'tags',
  isKeyResource: true
}, {
  'name': 'children',
  urlPart: 'children',
  isKeyResource: false
}, {
  'name': 'groups',
  urlPart: 'groups',
  isKeyResource: false
}, {
  'name': 'subcollections',
  urlPart: 'collections',
  isKeyResource: false
}, {
  'name': 'itemTypes',
  urlPart: 'itemTypes',
  isKeyResource: false
}, {
  'name': 'itemFields',
  urlPart: 'itemFields',
  isKeyResource: false
}, {
  'name': 'creatorFields',
  urlPart: 'creatorFields',
  isKeyResource: false
}, {
  'name': 'itemTypeFields',
  urlPart: 'itemTypeFields',
  isKeyResource: false
}, {
  'name': 'itemTypeCreatorTypes',
  urlPart: 'itemTypeCreatorTypes',
  isKeyResource: false
}, {
  'name': 'template',
  urlPart: 'items/new',
  isKeyResource: false
}, {
  'name': 'file',
  urlPart: 'file',
  isKeyResource: false
}, {
  'name': 'fileUrl',
  urlPart: 'file/view/url',
  isKeyResource: false
}, {
  'name': 'settings',
  urlPart: 'settings',
  isKeyResource: true
}, {
  'name': 'deleted',
  'urlPart': 'deleted',
  isKeyResource: false
}, {
  'name': 'verifyKeyAccess',
  urlPart: 'keys/current',
  isKeyResource: false
}];
var defaults = {
  apiAuthorityPart: 'api.zotero.org',
  cache: 'default',
  contentType: 'application/json',
  credentials: 'omit',
  format: 'json',
  method: 'get',
  mode: 'cors',
  pretend: false,
  redirect: 'follow',
  resource: {},
  retry: 0,
  retryDelay: null,
  uploadRegisterOnly: null
};
var makeUrlPath = resource => {
  var path = [];
  for (var resourcesSpec of resourcesSpecs) {
    var resourceValue = resource[resourcesSpec.name];
    if (resourcesSpec.name in resource) {
      if (resourcesSpec.name === 'library') {
        if (resourceValue.charAt(0) === 'u') {
          path.push('users', resourceValue.slice(1));
        } else if (resourceValue.charAt(0) === 'g') {
          path.push('groups', resourceValue.slice(1));
        }
      } else {
        path.push(resourcesSpec.urlPart);
        if (resourcesSpec.isKeyResource && resource[resourcesSpec.name]) {
          path.push(resourceValue);
        }
      }
    }
  }
  return path.join('/');
};
var makeUrlQuery = options => {
  var params = [];
  var _loop = function _loop(name) {
    if (options[name]) {
      if (_includesInstanceProperty__default["default"](queryParamsWithArraySupport).call(queryParamsWithArraySupport, name) && Array.isArray(options[name])) {
        params.push(...options[name].map(k => "".concat(name, "=").concat(encodeURIComponent(k))));
      } else {
        params.push("".concat(name, "=").concat(encodeURIComponent(options[name])));
      }
    }
  };
  for (var name of queryParamNames) {
    _loop(name);
  }
  return params.length ? '?' + params.join('&') : '';
};
var hasDefinedKey = (object, key) => {
  return key in object && object[key] !== null && typeof object[key] !== 'undefined';
};
var throwErrorResponse = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default["default"](function* (rawResponse, options, requestDesc) {
    var clonedRawResponse = rawResponse.clone();
    var reason = null;
    reason = yield clonedRawResponse.text();
    throw new ErrorResponse("".concat(requestDesc).concat(rawResponse.status, ": ").concat(rawResponse.statusText), reason, rawResponse, options);
  });
  return function throwErrorResponse(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
var isTransientFailure = response => response.status == 408 || response.status >= 500;
var sleep = seconds => {
  return new _Promise__default["default"](resolve => {
    setTimeout(() => {
      resolve();
    }, seconds * 1000);
  });
};

/**
 * Executes request and returns a response. Not meant to be called directly, instead use {@link
   module:zotero-api-client~api}.
 * @param {String} options.authorization					- 'Authorization' header
 * @param {String} options.zoteroWriteToken					- 'Zotero-Write-Token' header 
 * @param {String} options.ifModifiedSinceVersion			- 'If-Modified-Since-Version' header
 * @param {String} options.ifUnmodifiedSinceVersion			- 'If-Unmodified-Since-Version' header
 * @param {String} options.contentType						- 'Content-Type' header
 * @param {String} options.collectionKey					- 'collectionKey' query argument
 * @param {String} options.content							- 'content' query argument
 * @param {String} options.direction						- 'direction' query argument
 * @param {String} options.format							- 'format' query argument
 * @param {String} options.include							- 'include' query argument
 * @param {String} options.includeTrashed					- 'includeTrashed' query argument
 * @param {String} options.itemKey							- 'itemKey' query argument
 * @param {String} options.itemQ							- 'itemQ' query argument
 * @param {String} options.itemQMode						- 'itemQMode' query argument
 * @param {String|String[]} options.itemTag					- 'itemTag' query argument
 * @param {String} options.itemType							- 'itemType' query argument
 * @param {Number} options.limit							- 'limit' query argument
 * @param {String} options.linkMode							- 'linkMode' query argument
 * @param {String} options.locale							- 'locale' query argument
 * @param {String} options.q								- 'q' query argument
 * @param {String} options.qmode							- 'qmode' query argument
 * @param {String} options.searchKey						- 'searchKey' query argument
 * @param {Number} options.since							- 'since' query argument
 * @param {String} options.sort								- 'sort' query argument
 * @param {Number} options.start							- 'start' query argument
 * @param {String} options.style							- 'style' query argument
 * @param {String|String[]} options.tag						- 'tag' query argument
 * @param {Boolean} options.pretend							- triggers pretend mode where fetch request
 *                                        					  is prepared and returned without execution
 * @param {String} options.resource.top					    - use 'top' resource  
 * @param {String} options.resource.trash					- use 'trash' resource  
 * @param {String} options.resource.children				- use 'children' resource  	
 * @param {String} options.resource.groups					- use 'groups' resource  
 * @param {String} options.resource.itemTypes				- use 'itemTypes' resource  	
 * @param {String} options.resource.itemFields				- use 'itemFields' resource  	
 * @param {String} options.resource.creatorFields			- use 'creatorFields' resource  		
 * @param {String} options.resource.itemTypeFields			- use 'itemTypeFields' resource  		
 * @param {String} options.resource.itemTypeCreatorTypes	- use 'itemTypeCreatorTypes' resource  				
 * @param {String} options.resource.library					- use 'library' resource  
 * @param {String} options.resource.collections				- use 'collections' resource  	
 * @param {String} options.resource.items					- use 'items' resource  
 * @param {String} options.resource.searches				- use 'searches' resource  	
 * @param {String} options.resource.tags					- use 'tags' resource  
 * @param {String} options.resource.template				- use 'template' resource  	
 * @param {String} options.method 							- forwarded to fetch()
 * @param {String} options.body 							- forwarded to fetch()
 * @param {String} options.mode 							- forwarded to fetch()
 * @param {String} options.cache 							- forwarded to fetch()
 * @param {String} options.credentials 						- forwarded to fetch()
 * @param {Boolean} options.uploadRegisterOnly				- this file upload should only perform stage 1
 *                                           				  error if file with provided meta does not exist
 * @param {Number} options.retry							- retry this many times after transient error.
 * @param {Number} options.retryDelay						- wait this many seconds before retry. If not set
 *                                         					  an exponential backoff algorithm will be used
 * 
 * @return {Object} Returns a Promise that will eventually return a response object
 * @throws {Error} If options specify impossible configuration
 * @throws {ErrorResponse} If API responds with a non-ok response
 * @memberof module:zotero-api-client
 * @inner
 */
var request = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator__default["default"](function* (config) {
    var response;
    if ('response' in config && config.response) {
      return config;
    }
    var options = _objectSpread$1(_objectSpread$1({}, defaults), config);
    var headers = {};
    for (var header of Object.keys(headerNames)) {
      if (header in options) {
        headers[headerNames[header]] = options[header];
      }
    }
    var path = makeUrlPath(options.resource);
    var query = makeUrlQuery(options);
    var url = "https://".concat(options.apiAuthorityPart, "/").concat(path).concat(query);
    var fetchConfig = {};
    for (var param of fetchParamNames) {
      if (param === 'body' && hasDefinedKey(options, param)) {
        fetchConfig[param] = JSON.stringify(options[param]);
      } else {
        fetchConfig[param] = options[param];
      }
    }

    // build pre-upload (authorisation) request body based on the file provided
    if (hasDefinedKey(options, 'body') && hasDefinedKey(options, 'file')) {
      throw new Error('Cannot use both "file" and "body" in a single request.');
    }

    // process the request for file upload authorisation request
    if (hasDefinedKey(options, 'file') && hasDefinedKey(options, 'fileName')) {
      var fileName = options.fileName;
      var md5sum = SparkMD5__default["default"].ArrayBuffer.hash(options.file);
      var filesize = options.file.byteLength;
      var mtime = options.mtime || Date.now();
      fetchConfig['body'] = "md5=".concat(md5sum, "&filename=").concat(fileName, "&filesize=").concat(filesize, "&mtime=").concat(mtime);
    }
    if (options.uploadRegisterOnly === true) {
      var {
        fileName: _fileName,
        fileSize,
        md5sum: _md5sum,
        mtime: _mtime
      } = options;
      fetchConfig['body'] = "md5=".concat(_md5sum, "&filename=").concat(_fileName, "&filesize=").concat(fileSize, "&mtime=").concat(_mtime);
    }

    // checking against access-control-allow-methods seems to be case sensitive
    fetchConfig.method = fetchConfig.method.toUpperCase();
    fetchConfig.headers = headers;
    options.retryCount = 0;
    if (options.pretend) {
      var _response = new PretendResponse({
        url,
        fetchConfig
      }, options);
      return _objectSpread$1(_objectSpread$1({
        response: _response
      }, config), {}, {
        source: 'request'
      });
    }
    var rawResponse = yield fetch(url, fetchConfig);
    if (isTransientFailure(rawResponse) && options.retry > 0) {
      var retriesCounter = options.retry;
      var nextRetryDelay = typeof options.retryDelay === 'number' ? options.retryDelay : 1;
      while (retriesCounter > 0) {
        yield sleep(nextRetryDelay);
        options.retryCount++;
        rawResponse = yield fetch(url, fetchConfig);
        if (!isTransientFailure(rawResponse)) {
          break;
        }
        if (typeof options.retryDelay !== 'number') {
          nextRetryDelay *= 2;
        }
        retriesCounter--;
      }
    }
    if (hasDefinedKey(options, 'file') && hasDefinedKey(options, 'fileName') || options.uploadRegisterOnly === true) {
      if (rawResponse.ok) {
        var authData = yield rawResponse.json();
        if ('exists' in authData && authData.exists) {
          response = new FileUploadResponse(authData, options, rawResponse);
        } else {
          if (options.uploadRegisterOnly === true) {
            throw new ErrorResponse('API did not recognize provided file meta.', 'Attempted to register existing file, but API did not recognize provided file meta.', rawResponse, options);
          }
          var prefix = new Uint8ClampedArray(authData.prefix.split('').map(e => e.charCodeAt(0)));
          var suffix = new Uint8ClampedArray(authData.suffix.split('').map(e => e.charCodeAt(0)));
          var body = new Uint8ClampedArray(prefix.byteLength + options.file.byteLength + suffix.byteLength);
          body.set(prefix, 0);
          body.set(new Uint8ClampedArray(options.file), prefix.byteLength);
          body.set(suffix, prefix.byteLength + options.file.byteLength);

          // follow-up request
          var uploadResponse = yield fetch(authData.url, {
            headers: {
              [headerNames['contentType']]: authData.contentType
            },
            method: 'post',
            body: body.buffer
          });
          if (uploadResponse.status === 201) {
            var registerResponse = yield fetch(url, _objectSpread$1(_objectSpread$1({}, fetchConfig), {}, {
              body: "upload=".concat(authData.uploadKey)
            }));
            if (!registerResponse.ok) {
              return yield throwErrorResponse(registerResponse, options, 'Upload stage 3: ');
            }
            response = new FileUploadResponse({}, options, rawResponse, uploadResponse, registerResponse);
          } else {
            return yield throwErrorResponse(uploadResponse, options, 'Upload stage 2: ');
          }
        }
      } else {
        return yield throwErrorResponse(rawResponse, options, 'Upload stage 1: ');
      }
    } else {
      if (rawResponse.status < 200 || rawResponse.status >= 400) {
        return yield throwErrorResponse(rawResponse, options, '');
      }
      var content;
      if (options.format === 'json') {
        try {
          content = yield rawResponse.json();
        } catch (_) {
          content = null;
        }
        switch (options.method.toUpperCase()) {
          case 'GET':
          default:
            if ('library' in options.resource) {
              if (content && Array.isArray(content)) {
                response = new MultiReadResponse(content, options, rawResponse);
              } else {
                response = new SingleReadResponse(content, options, rawResponse);
              }
            } else {
              response = new ApiResponse(content, options, rawResponse);
            }
            break;
          case 'POST':
          case 'PUT':
          case 'PATCH':
            if (content && typeof content === 'object' && 'success' in content) {
              response = new MultiWriteResponse(content, options, rawResponse);
            } else {
              response = new SingleWriteResponse(content, options, rawResponse);
            }
            break;
          case 'DELETE':
            response = new DeleteResponse(content, options, rawResponse);
            break;
        }
      } else {
        if ('file' in options.resource && options.method.toUpperCase() === 'GET') {
          var rawData = yield rawResponse.arrayBuffer();
          response = new FileDownloadResponse(rawData, options, rawResponse);
        } else if ('fileUrl' in options.resource && options.method.toUpperCase() === 'GET') {
          var _context;
          var _url = yield rawResponse.text();
          response = new FileUrlResponse(_trimInstanceProperty__default["default"](_context = _url.replace('\n', '')).call(_context), options, rawResponse);
        } else {
          response = new RawApiResponse(rawResponse, options);
        }
      }
    }
    return _objectSpread$1(_objectSpread$1({}, config), {}, {
      source: 'request',
      response
    });
  });
  return function request(_x4) {
    return _ref2.apply(this, arguments);
  };
}();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * @module zotero-api-client
 */

/**
 * Wrapper function creates closure scope and calls api()
 * @return {Object} Partially configured api functions
 */
var api = function api() {
  /**
   * Entry point of the interface. Configures authentication.
   * Can be used to configure any other properties of the api
   * Returns a set of function that are bound to that configuration
   * and can be called to specify further api configuration.
   * @param  {String} key  - Authentication key
   * @param  {Object} opts - Optional api configuration. For a list of all
   *                         possible properties, see documentation for
   *                         request() function
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var api = function api() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var props = _objectSpread({}, opts);
    if (!('executors' in props) && (!this || !('executors' in this))) {
      props.executors = [request];
    }
    if (key) {
      props.zoteroApiKey = key;
    }
    return ef.bind(this)(props);
  };

  /**
   * Configures which library api requests should use.
   * @chainable
   * @param {*} [typeOrKey] - Library key, e.g. g1234. Alternatively, if
   *                          second parameter is present, library type i.e
   *                          either 'group' or 'user'
   * @param {Number} [id]   - Only when first argument is a type, library id
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var library = function library() {
    var libraryKey;
    if (arguments.length > 1) {
      switch (arguments[0].toLowerCase()) {
        case 'user':
          libraryKey = "u".concat(arguments[1]);
          break;
        case 'group':
          libraryKey = "g".concat(arguments[1]);
          break;
        default:
          throw new Error("Unrecognized library type ".concat(arguments[0]));
      }
    } else {
      libraryKey = arguments[0];
    }
    return efr.bind(this)({
      library: libraryKey
    });
  };

  /**
   * Configures api to use items or a specific item
   * Can be used in conjuction with library(), collections(), top(), trash(),
   * children(), tags() and any execution function (e.g. get(), post())
   * @param  {String} items - Item key, if present, configure api to point at
   *                          this specific item
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var items = function items() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return efr.bind(this)({
      items
    });
  };

  /**
   * Configure api to request all item types
   * Can only be used in conjuction with get()
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var itemTypes = function itemTypes() {
    return efr.bind(this)({
      itemTypes: null
    });
  };

  /**
   * Configure api to request all item fields
   * Can only be used in conjuction with get()
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var itemFields = function itemFields() {
    return efr.bind(this)({
      itemFields: null
    });
  };

  /**
   * Configure api to request localized creator fields
   * Can only be used in conjuction with get()
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var creatorFields = function creatorFields() {
    return efr.bind(this)({
      creatorFields: null
    });
  };

  /**
   * Configure api to request all valid fields for an item type
   * Can only be used in conjuction with get()
   * @param  {String} itemType - item type for which valid fields will be
   *                             requested, e.g. 'book' or 'journalType'
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var itemTypeFields = function itemTypeFields(itemType) {
    return efr.bind(this)({
      itemTypeFields: null
    }, itemType ? {
      itemType
    } : {});
  };

  /**
   * Configure api to request valid creator types for an item type
   * Can only be used in conjuction with get()
   * @param  {String} itemType - item type for which valid creator types
   *                             will be requested, e.g. 'book' or 
   *                             'journalType'
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var itemTypeCreatorTypes = function itemTypeCreatorTypes(itemType) {
    return efr.bind(this)({
      itemTypeCreatorTypes: null
    }, itemType ? {
      itemType
    } : {});
  };

  /**
   * Configure api to request template for a new item
   * Can only be used in conjuction with get()
   * @param  {String} itemType - item type for which template will be
   *                             requested, e.g. 'book' or 'journalType'
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var template = function template(itemType) {
    return efr.bind(this)({
      template: null
    }, itemType ? {
      itemType
    } : {});
  };

  /**
   * Configure api to use collections or a specific collection
   * Can be used in conjuction with library(), items(), top(), tags() and
   * any of the execution function (e.g. get(), post())
   * @param  {String} items - Collection key, if present, configure api to
   *                          point to this specific collection
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var collections = function collections(_collections) {
    return efr.bind(this)({
      collections: _collections || null
    });
  };

  /**
   * Configure api to use subcollections that reside underneath the specified
   * collection.
   * Should only be used in conjuction with both library() and collection()
   * and any of the execution function (e.g. get(), post())
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var subcollections = function subcollections() {
    return efr.bind(this)({
      subcollections: null
    });
  };

  /**
   * Configure api to narrow the request to only consider items filled under
   * "My Publications"
   * Should only be used in conjuction with both library() and items()
   * and any of the execution function (e.g. get(), post())
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var publications = function publications() {
    return efr.bind(this)({
      publications: null
    });
  };
  /**
   * Configure api to request or delete tags or request a specific tag
   * Can be used in conjuction with library(), items(), collections() and
   * any of the following execution functions: get(), delete() but only
   * if the first argument is not present. Otherwise can only be used in
   * conjuctin with get()
   * @param  {String} tags - name of a tag to request. If preset, configure
   *                         api to request specific tag.
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var tags = function tags() {
    var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return efr.bind(this)({
      tags
    });
  };

  /**
   * Configure api to use saved searches or a specific saved search
   * Can be used in conjuction with library() and any of the execution
   * functions
   * @param  {String} searches - Search key, if present, configure api to point at
   *                             this specific saved search
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var searches = function searches() {
    var searches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return efr.bind(this)({
      searches: searches
    });
  };

  /**
   * Configure api to narrow the request only to the top level items
   * Can be used in conjuction with items() and collections() and only
   * with conjuction with a get() execution function
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var top = function top() {
    return efr.bind(this)({
      top: null
    });
  };

  /**
   * Configure api to narrow the request only to the items in the trash
   * Can be only used in conjuction with items() and get() execution
   * function
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var trash = function trash() {
    return efr.bind(this)({
      trash: null
    });
  };

  /**
   * Configure api to narrow the request only to the children of given
   * item
   * Can be only used in conjuction with items() and get() execution
   * function
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var children = function children() {
    return efr.bind(this)({
      children: null
    });
  };

  /**
   * Configure api to request settings
   * Can only be used in conjuction with get(), put(), post() and delete()
   * For usage with put() and delete() settings key must be provided
   * For usage with post() settings key must not be included
   * @param  {String} settings - Settings key, if present, configure api to point at
   *                             this specific key within settings, e.g. `tagColors`.
  	 * @return {Object} Partially configured api functions
   * @chainable
   */
  var settings = function settings() {
    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return efr.bind(this)({
      settings
    });
  };

  /**
   * Configure api to request deleted content
   * Can only be used in conjuction with get()
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var deleted = function deleted(since) {
    var resource = _objectSpread(_objectSpread({}, this.resource), {}, {
      deleted: null
    });
    return ef.bind(this)({
      since,
      resource
    });
  };

  /**
   * Configure api to request user-accessible groups (i.e. The set of groups 
   * the current API key has access to, including public groups the key owner
   * belongs to even if the key doesn't have explicit permissions for them.)
   * Can only be used in conjuction with get()
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var groups = function groups() {
    return efr.bind(this)({
      groups: null
    });
  };

  /**
   * Configure api to specify local version of given entity.
   * When used in conjuction with get() exec function, it will populate the
   * If-Modified-Since-Version header.
   * When used in conjuction with post(), put(), patch() or delete() it will
   * populate the If-Unmodified-Since-Version header.
   * @param  {Number} version - local version of the entity
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var version = function version() {
    var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return ef.bind(this)({
      version: version
    });
  };

  /**
   * Configure api to upload or download an attachment file
   * Can be only used in conjuction with items() and post()/get()
   * Use items() to select attachment item for which file is uploaded/downloaded
   * Will populate format on download as well as Content-Type, If-None-Match headers
   * in case of an upload
   * @param  {String} fileName  - name of the file, should match values in attachment
   *                              item entry
   * @param  {ArrayBuffer} file - file to be uploaded
   * @param  {Number} mtime     - file's mtime, if not provided current time is used
   * @param  {Number} md5sum    - existing file md5sum, if matches will override existing file. Leave empty to perform new upload.
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var attachment = function attachment(fileName, file) {
    var mtime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var md5sum = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var resource = _objectSpread(_objectSpread({}, this.resource), {}, {
      file: null
    });
    if (fileName && file) {
      return ef.bind(this)({
        format: null,
        [md5sum ? 'ifMatch' : 'ifNoneMatch']: md5sum || '*',
        contentType: 'application/x-www-form-urlencoded',
        fileName,
        file,
        resource,
        mtime
      });
    } else {
      return ef.bind(this)({
        format: null,
        resource
      });
    }
  };

  /**
   * Advanced, low-level function that will attempt to register existing 
   * file with given attachment-item based on known file metadata
   * Can be only used in conjuction with items() and post()
   * Use items() to select attachment item for which file is registered
   * Will populate Content-Type, If-Match headers
   * Will fail with a ErrorResponse if API does not return "exists"
   * @param  {String} fileName  - name of the file, should match values in attachment
   *                              item entry
   * @param  {Number} fileSize  - size of the existing file
   * @param  {Number} mtime     - mtime of the existing file
   * @param  {String} md5sum    - md5sum of the existing file
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var registerAttachment = function registerAttachment(fileName, fileSize, mtime, md5sum) {
    var resource = _objectSpread(_objectSpread({}, this.resource), {}, {
      file: null
    });
    if (fileName && typeof fileSize !== 'undefined' && typeof mtime !== 'undefined' && md5sum) {
      return ef.bind(this)({
        contentType: 'application/x-www-form-urlencoded',
        fileName,
        fileSize,
        format: null,
        ifMatch: md5sum,
        md5sum,
        mtime,
        resource,
        uploadRegisterOnly: true
      });
    } else {
      throw new Error('Called registerAttachment() without specifing required parameters');
    }
  };

  /**
   * Configure api to request a temporary attachment file url
   * Can be only used in conjuction with items() and get()
   * Use items() to select attachment item for which file is url is requested
   * Will populate format, redirect
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var attachmentUrl = function attachmentUrl() {
    var resource = _objectSpread(_objectSpread({}, this.resource), {}, {
      fileUrl: null
    });
    return ef.bind(this)({
      format: null,
      resource
    });
  };

  /**
   * Configure api to request information on the API key.
   * Can only be used in conjuction with get()
   *
   * @return {Object} Partially configured api functions
   * @chainable
   */
  var verifyKeyAccess = function verifyKeyAccess() {
    return efr.bind(this)({
      verifyKeyAccess: null
    });
  };

  /**
   * Execution function. Specifies that the request should use a GET method.
   * @param  {Object} opts - Optional api configuration. If duplicate, 
   *                         overrides properties already present. For a list
   *                         of all possible properties, see documentation
   *                         for request() function
   * @return {Promise} A promise that will eventually return either an 
   *                   ApiResponse, SingleReadResponse or MultiReadResponse.
   *                   Might throw Error or ErrorResponse.
   */
  var get = function get(opts) {
    return execute(prepareRequest(this, 'get', opts));
  };

  /**
   * Execution function. Specifies that the request should use a POST method.
   * @param  {Array} data  - An array of entities to post
   * @param  {Object} opts - Optional api configuration. If duplicate, 
   *                         overrides properties already present. For a list
   *                         of all possible properties, see documentation
   *                         for request() function
   * @return {Promise} A promise that will eventually return MultiWriteResponse.
   *                   Might throw Error or ErrorResponse
   */
  var post = function post(data, opts) {
    return execute(prepareRequest(this, 'post', opts, data));
  };

  /**
   * Execution function. Specifies that the request should use a PUT method.
   * @param  {Object} data - An entity to put
   * @param  {Object} opts - Optional api configuration. If duplicate, 
   *                         overrides properties already present. For a list
   *                         of all possible properties, see documentation
   *                         for request() function
   * @return {Promise} A promise that will eventually return SingleWriteResponse.
   *                   Might throw Error or ErrorResponse
   */
  var put = function put(data, opts) {
    return execute(prepareRequest(this, 'put', opts, data));
  };

  /**
   * Execution function. Specifies that the request should use a PATCH
   * method.
   * @param  {Object} data - Partial entity data to patch
   * @param  {Object} opts - Optional api configuration. If duplicate, 
   *                         overrides properties already present. For a list
   *                         of all possible properties, see documentation
   *                         for request() function
   * @return {Promise} A promise that will eventually return SingleWriteResponse.
   *                   Might throw Error or ErrorResponse
   */
  var patch = function patch(data, opts) {
    return execute(prepareRequest(this, 'patch', opts, data));
  };

  /**
   * Execution function. Specifies that the request should use a DELETE
   * method.
   * @param  {Array} keysToDelete - An array of keys to delete. Depending on
   *                                how api has been configured, these will
   *                                be item keys, collection keys, search 
   *                                keys or tag names. If not present, api
   *                                should be configured to use specific 
   *                                item, collection, saved search or settings
   *                                key, in which case, that entity will be deleted
   * @param  {Object} opts - Optional api configuration. If duplicate, 
   *                         overrides properties already present. For a list
   *                         of all possible properties, see documentation
   *                         for request() function
   * @return {Promise} A promise that will eventually return DeleteResponse.
   *                   Might throw Error or ErrorResponse
   */
  var del = function del(keysToDelete, opts) {
    return execute(prepareRequest(this, 'delete', opts, keysToDelete));
  };

  /**
   * Execution function. Returns current config without doing any requests.
   * Usually used in advanced scenarios where config needs to be tweaked
   * manually before submitted to the request method or as a debugging tool.
   * @return {Object} current config
   */
  var getConfig = function getConfig() {
    return this;
  };

  /**
   * Execution function. Prepares the request but does not execute fetch()
   * instead returning a "pretended" response where details for the actual
   * fetch that would have been used are included.
   * Usually used in advanced scenarios where config needs to be tweaked
   * manually before submitted to the request method or as a debugging tool.
   * @param  {String} verb - Defines which execution function is used to prepare
   *                         the request. Should be one of 'get', 'post', 'patch'
   *                         'put', 'delete'. Defaults to 'get'.
   * @param  {Object} data - This argument is passed over to the actual execution
   *                         function. For 'get' it is ignored, for 'post', 'patch'
   *                         and 'put' see 'data' of that execution function, for
   *                         'delete' see 'keysToDelete'
   * @param  {Object} opts - Optional api configuration. If duplicate, 
   *                         overrides properties already present. For a list
   *                         of all possible properties, see documentation
   *                         for request() function
   * @return {Promise} A promise that will eventually return PretendResponse.
   *                   Might throw Error or ErrorResponse
   */
  var pretend = function pretend() {
    var verb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'get';
    var data = arguments.length > 1 ? arguments[1] : undefined;
    var opts = arguments.length > 2 ? arguments[2] : undefined;
    return execute(prepareRequest(this, verb, _objectSpread(_objectSpread({}, opts), {}, {
      pretend: true
    }), data));
  };

  /**
   * Used for extending capabilities of the library by installing plugins.
   * In most cases plugins inject additional executors or bind api to an
   * alternative/extended set of functions
   * @param  {function} extend  - function that installs alternative
   *                              or additional functionality of the api.
   *                              It should return bound api functions,
   *                              usually by caling arguments[0].ef()
   * @return {Object} Extended/partially configured api functions
   */
  var use = function use(extend) {
    return extend({
      config: this,
      functions,
      ef,
      efr,
      execute
    });
  };
  var functions = {
    api,
    attachment,
    attachmentUrl,
    children,
    collections,
    creatorFields,
    delete: del,
    //delete is a keyword
    deleted,
    get,
    getConfig,
    groups,
    itemFields,
    items,
    itemTypeCreatorTypes,
    itemTypeFields,
    itemTypes,
    library,
    patch,
    post,
    pretend,
    publications,
    put,
    registerAttachment,
    searches,
    settings,
    subcollections,
    tags,
    template,
    top,
    trash,
    use,
    verifyKeyAccess,
    version
  };
  var ef = function ef(opts) {
    var context = _objectSpread(_objectSpread({}, this), opts);
    var enhancedFunctions = {};
    for (var fname in functions) {
      enhancedFunctions[fname] = functions[fname].bind(context);
    }
    return enhancedFunctions;
  };
  var efr = function efr(resource, opts) {
    resource = _objectSpread(_objectSpread({}, this.resource), resource);
    opts = _objectSpread(_objectSpread({}, opts), {}, {
      resource
    });
    return ef.bind(this)(opts);
  };
  var prepareRequest = function prepareRequest(config, verb, opts, body) {
    var method = verb.toLowerCase();
    var relevantSearchKey;
    var requestConfig, keysToDelete;
    switch (method) {
      default:
      case 'get':
        requestConfig = _objectSpread(_objectSpread(_objectSpread({}, config), opts), {}, {
          method
        });
        if ('version' in requestConfig) {
          requestConfig['ifModifiedSinceVersion'] = requestConfig['version'];
          delete requestConfig['version'];
        }
        return requestConfig;
      case 'post':
      case 'put':
      case 'patch':
        requestConfig = _objectSpread(_objectSpread(_objectSpread({}, config), opts), {}, {
          body,
          method
        });
        if ('version' in requestConfig) {
          requestConfig['ifUnmodifiedSinceVersion'] = requestConfig['version'];
          delete requestConfig['version'];
        }
        return requestConfig;
      case 'delete':
        requestConfig = _objectSpread(_objectSpread(_objectSpread({}, config), opts), {}, {
          method
        });
        keysToDelete = body;
        if (keysToDelete && !Array.isArray(keysToDelete)) {
          throw new Error("Called delete() with ".concat(typeof keysToDelete, ", expected an Array"));
        }
        if ('version' in requestConfig) {
          requestConfig['ifUnmodifiedSinceVersion'] = requestConfig['version'];
          delete requestConfig['version'];
        }
        if ('resource' in requestConfig && 'items' in requestConfig.resource) {
          relevantSearchKey = 'itemKey';
        } else if ('resource' in requestConfig && 'collections' in requestConfig.resource) {
          relevantSearchKey = 'collectionKey';
        } else if ('resource' in requestConfig && 'tags' in requestConfig.resource) {
          relevantSearchKey = 'tag';
        } else if ('resource' in requestConfig && 'searches' in requestConfig.resource) {
          relevantSearchKey = 'searchKey';
        } else if ('resource' in requestConfig && 'settings' in requestConfig.resource) {
          if (keysToDelete) {
            throw new Error('Arguments to delete() not supported when deleting settings');
          }
        } else {
          throw new Error('Called delete() without first specifing what to delete');
        }
        if (keysToDelete) {
          requestConfig[relevantSearchKey] = [...(requestConfig[relevantSearchKey] || []), ...keysToDelete];
        }
        return requestConfig;
    }
  };
  var execute = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default["default"](function* (config) {
      for (var f of config.executors) {
        config = yield f(config);
      }
      return config.response;
    });
    return function execute(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  return api(...arguments);
};

exports.ApiResponse = ApiResponse;
exports.DeleteResponse = DeleteResponse;
exports.ErrorResponse = ErrorResponse;
exports.FileDownloadResponse = FileDownloadResponse;
exports.FileUploadResponse = FileUploadResponse;
exports.FileUrlResponse = FileUrlResponse;
exports.MultiReadResponse = MultiReadResponse;
exports.MultiWriteResponse = MultiWriteResponse;
exports.PretendResponse = PretendResponse;
exports.RawApiResponse = RawApiResponse;
exports.SingleReadResponse = SingleReadResponse;
exports.SingleWriteResponse = SingleWriteResponse;
exports["default"] = api;
exports.request = request;
